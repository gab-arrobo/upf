# SPDX-License-Identifier: Apache-2.0
# Copyright 2023 Intel Corporation

from conf.parser import *
import conf.ports as port
import conf.sim as sim
import signal
import sys

port.setup_globals()


# ====================================================
#	Read json config file (START HERE)
# ====================================================

interfaces = ["access", "core"]
parser = Parser('conf/pktgen.jsonc')
parser.parse(interfaces)

if parser.mode == 'sim':
    print('Please update pktgen.jsonc and pktgen_setup.sh accordingly')
    sys.exit('This file is NOT meant to work in simulation mode')

# Catch core & access MAC/IPv4 addresses
core_mac = mac_by_interface(parser.core_ifname)
access_mac = mac_by_interface(parser.access_ifname)
core_ip = ips_by_interface(parser.core_ifname)
access_ip = ips_by_interface(parser.access_ifname)


# ====================================================
# TODO: GA: Parameters to (manually) update
core_dst_mac = "b4:96:91:b4:47:b8" # MAC address for UPF's core port
access_dst_mac = "b4:96:91:b4:47:b9" # MAC address for UPF's access port
access_dst_ip = "198.18.0.1" # IP address for UPF's access port
# ====================================================


# ====================================================
#       Core Setup
# ====================================================


# Initialize workers
cores = get_process_affinity()
workers = cores[:parser.workers]
if len(cores) > parser.workers:
    nonworkers = cores[parser.workers:]
else:
    nonworkers = cores

set_process_affinity_all(nonworkers)
for wid in range(parser.workers):
    bess.add_worker(wid=wid, core=int(workers[wid % len(workers)]))


# ====================================================
#       Port Setup
# ====================================================

ports = {}

for idx, iface in enumerate(interfaces):
    # check if source natting for a given port is required
    try:
        ext_addrs = parser.interfaces[iface]["ip_masquerade"]
    except KeyError:
        ext_addrs = None
    except TypeError:
        ext_addrs = None

    p = port.Port(parser.interfaces[iface]["ifname"], parser.hwcksum, ext_addrs)
    if p.name in ports:
        continue

    if parser.ddp:
        p.configure_flow_profiles(iface)

    if parser.mode == 'cndp':
        p.configure_cndp(parser.interfaces[iface]["cndp_jsonc_file"], iface, len(workers))

    # initialize port with the configured driver
    p.workers = [i for i in range(len(workers))]
    p.init_port(idx, parser.mode)

    # setup port module with auxiliary modules
    p.setup_port(parser.ip_frag_with_eth_mtu, parser.max_ip_defrag_flows, parser.measure_upf)

    # Finally add entry to ports list
    ports[p.name] = p


# ====================================================
#       Downlink packet generation
# ====================================================

n6_pkts = [sim.gen_inet_packet(parser.sim_pkt_size, core_mac, core_dst_mac,
                               parser.sim_n6_app_ip, parser.sim_start_ue_ip)]
n6_seq = sim.gen_inet_sequpdate_args(parser.sim_total_flows, parser.sim_start_ue_ip)

n6TxSrc::Source() -> n6TxGen::Rewrite(templates=n6_pkts) \
    -> n6TxSeq::SequentialUpdate(**n6_seq) -> n6TxL4Cksum::L4Checksum() \
    -> n6TxIPCksum::IPChecksum() -> ports[parser.core_ifname].rtr
n6TxSrc.set_burst(burst=1)

bess.add_tc('schedule_limit_dl',
            policy='rate_limit',
            resource='count',
            limit={'count': parser.dl_rate})
n6TxSrc.attach_task(parent='schedule_limit_dl')


# ====================================================
#       Downlink packet reception
# ====================================================

n3RxFastBPF = ports[parser.access_ifname].bpf
GTPUGate = 0

n3RxFastBPF:GTPUGate \
    -> n3RxIPCksum::IPChecksum(verify=True, hw=parser.hwcksum) \
    -> n3RxL4Cksum::L4Checksum(verify=True, hw=parser.hwcksum) \
    -> n3RxSink::Sink()

# Add Access filter rules, i.e.:
# setting filter to detect gtpu traffic
# and dst host 11.1.1.1                         # check S/PGWU IP
# and udp dst port 2152                         # check GTPU port
check_ip = "ip"
check_spgwu_ip = " and dst host " + \
    " or ".join(str(x) for x in access_ip)
check_gtpu_port = " and udp dst port 2152"

# PDU rule
uplink_filter = {"priority": -GTPUGate, "filter": check_ip +
               check_spgwu_ip + check_gtpu_port, "gate": GTPUGate}
n3RxFastBPF.add(filters=[uplink_filter])


# ====================================================
#       Uplink packet generation
# ====================================================

n3_pkts = [sim.gen_inet_packet(parser.sim_pkt_size, access_mac, access_dst_mac,
                               parser.sim_start_ue_ip, parser.sim_n6_app_ip)]
n3_seq = sim.gen_inet_sequpdate_ul_args(parser.sim_total_flows, parser.sim_start_ue_ip)
gtpu_seq = sim.gen_gtpu_sequpdate_ul_args(parser.sim_total_flows, parser.sim_start_n3_teid)

n3TxSrc::Source() -> n3TxGen::Rewrite(templates=n3_pkts) \
    -> n3TxSeq::SequentialUpdate(**n3_seq) -> n3TxL4Cksum::L4Checksum() \
    -> n3TxIPCksum::IPChecksum() -> gtpuEncap::GtpuEncap(add_psc=parser.gtppsc):1 \
    -> Update(fields=[{'offset': 26, 'size': 4, 'value': ip2long(parser.sim_start_enb_ip)}, \
                      {'offset': 30, 'size': 4, 'value': ip2long(access_dst_ip)}, \
                      {'offset': 34, 'size': 2, 'value': 2152}, \
                      {'offset': 36, 'size': 2, 'value': 2152}]) \
    -> gtpuTxSeq::SequentialUpdate(**gtpu_seq) -> gtpuL4Cksum::L4Checksum() \
    -> gtpuIPCksum::IPChecksum() -> ports[parser.access_ifname].rtr

    # TODO: GA: gtpuParse not properly working (maybe some input/metadata is missing)
    # -> metadata::SetMetadata(attrs=[{'name': 'src_iface', 'size': 1, 'value_int': 2}]) \
    # -> gtpuParse::GtpuParser():1 -> gtpuEncap::GtpuEncap(add_psc=False):1 \

n3TxSrc.set_burst(burst=1)

bess.add_tc('schedule_limit_ul',
            policy='rate_limit',
            resource='count',
            limit={'count': parser.ul_rate})
n3TxSrc.attach_task(parent='schedule_limit_ul')


# ====================================================
#       Uplink packet reception
# ====================================================

n6RxFastBPF = ports[parser.core_ifname].bpf
UEGate = 0
if ports[parser.core_ifname].ext_addrs is not None:
    UEGate = ports[parser.core_ifname].bpf_gate()
    ports[parser.core_ifname].bpf -> Sink()

gate = 0
n6RxFastBPF:UEGate \
    -> n6RxIPCksum::IPChecksum(verify=True, hw=parser.hwcksum) \
    -> n6RxL4Cksum::L4Checksum(verify=True, hw=parser.hwcksum) \
    -> n6RxSink::Sink()

# Add Core filter rules, i.e.:
# setting filter to detect gtpu traffic
# and dst host x.x.x.x                         # check S/PGWU IP
# and udp dst port 2152                         # check GTPU port
check_ip = "ip"
check_spgwu_ip = " and dst host " + \
    " or ".join(str(x) for x in core_ip)
check_gtpu_port = " and udp dst port 2152"
GTPUGate = 0 #ports[parser.core_ifname].bpf_gate()
downlink_filter = {"priority": -GTPUGate, "filter": check_ip +
               check_spgwu_ip + check_gtpu_port, "gate": GTPUGate}
n6RxFastBPF.add(filters=[downlink_filter])

ports[parser.access_ifname].rtr.delete(prefix='0.0.0.0', prefix_len=0)
ports[parser.access_ifname].rtr.add(prefix='0.0.0.0', prefix_len=0, gate=0)


# ====================================================
#       Route Control
# ====================================================
# Finally send SIGHUP to route_control daemon on reload
# TODO: behavior is unspecified if route_control.py pid is not found
route_control_pid = getpythonpid('route_control.py')
if route_control_pid:
    os.kill(route_control_pid, signal.SIGHUP)
